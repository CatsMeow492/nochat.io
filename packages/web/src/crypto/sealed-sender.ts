/**
 * Sealed Sender module for nochat.io
 *
 * Implements Sealed Sender encryption to hide message sender identity from the server.
 * The server can route messages based on recipient_id, but cannot determine who sent the message.
 * The sender's identity is encrypted inside the sealed envelope.
 *
 * Protocol Overview:
 * 1. Sender encrypts inner envelope (containing sender_id, message content) to recipient's sealed sender key
 * 2. Server receives outer envelope with only recipient_id visible
 * 3. Recipient decapsulates to reveal sender identity and message
 *
 * Privacy Features:
 * - Sender identity hidden from server
 * - Delivery tokens prevent unauthorized sealed sender messages
 * - Timestamp bucketing (15-minute windows) for timing privacy
 * - Fixed-size padding blocks for traffic analysis protection
 */

import { ml_kem1024 } from '@noble/post-quantum/ml-kem.js';
import {
  randomBytes,
  toBase64,
  fromBase64,
  sha256,
  hkdfDerive,
  concat,
  toHex,
} from './utils';
import { encryptAESGCM, decryptAESGCM } from './symmetric';
import { KYBER1024_PUBLIC_KEY_SIZE, KYBER1024_PRIVATE_KEY_SIZE } from './pqc';

// Sealed sender envelope protocol version
export const SEALED_SENDER_VERSION = 1;

// Padding block sizes (bytes)
export const PADDING_BLOCK_SIZES = [256, 1024, 4096, 16384, 65536];

// Timestamp bucket size (15 minutes in milliseconds)
export const TIMESTAMP_BUCKET_MS = 15 * 60 * 1000;

/**
 * Inner envelope structure (decrypted by recipient only)
 */
export interface InnerEnvelope {
  senderId: string;
  senderIdentityKey: string; // Base64 encoded
  senderKeyFingerprint: string;
  messageContent: Uint8Array; // Double Ratchet encrypted payload
  trueTimestamp: number; // Actual message time (hidden from server)
  conversationId?: string; // For group messages
  messageId?: string; // For deduplication in groups
}

/**
 * Sealed envelope structure (sent to server)
 */
export interface SealedEnvelope {
  kemCiphertext: Uint8Array; // Kyber KEM ciphertext
  nonce: Uint8Array; // AES-GCM nonce
  encryptedContent: Uint8Array; // Encrypted inner envelope
}

/**
 * Sealed sender key pair (generated by each user)
 */
export interface SealedSenderKeyPair {
  publicKey: Uint8Array; // Kyber public key (1568 bytes)
  privateKey: Uint8Array; // Kyber private key (3168 bytes)
}

/**
 * WebSocket sealed message format
 */
export interface WSSealedMessage {
  type: 'sealedMessage';
  recipientId: string;
  sealedContent: string; // Base64 encoded SealedEnvelope
  deliveryToken: string; // Base64 encoded
  timestampBucket: number;
}

/**
 * WebSocket sealed group message format
 */
export interface WSSealedGroupMessage {
  type: 'sealedGroupMessage';
  conversationId: string;
  encryptedEnvelope: string; // Base64 encoded (shared)
  sealedKeys: WSSealedKey[];
  timestampBucket: number;
}

/**
 * Per-recipient sealed key for group fanout
 */
export interface WSSealedKey {
  recipientId: string;
  sealedContentKey: string; // Base64 encoded
  ephemeralPublicKey: string; // Base64 encoded
  kemCiphertext: string; // Base64 encoded
  deliveryToken: string; // Base64 encoded
}

/**
 * Generate a sealed sender key pair
 */
export async function generateSealedSenderKeyPair(): Promise<SealedSenderKeyPair> {
  const keys = ml_kem1024.keygen();
  return {
    publicKey: keys.publicKey,
    privateKey: keys.secretKey,
  };
}

/**
 * Encrypt an inner envelope to a recipient's sealed sender public key
 *
 * @param innerEnvelope The inner envelope to encrypt
 * @param recipientPublicKey Recipient's sealed sender Kyber public key
 * @returns Sealed envelope ready for transmission
 */
export async function sealedSenderEncrypt(
  innerEnvelope: InnerEnvelope,
  recipientPublicKey: Uint8Array
): Promise<SealedEnvelope> {
  if (recipientPublicKey.length !== KYBER1024_PUBLIC_KEY_SIZE) {
    throw new Error(
      `Invalid recipient public key size: expected ${KYBER1024_PUBLIC_KEY_SIZE}, got ${recipientPublicKey.length}`
    );
  }

  // 1. Serialize and pad the inner envelope
  const serialized = new TextEncoder().encode(JSON.stringify({
    senderId: innerEnvelope.senderId,
    senderIdentityKey: innerEnvelope.senderIdentityKey,
    senderKeyFingerprint: innerEnvelope.senderKeyFingerprint,
    messageContent: toBase64(innerEnvelope.messageContent),
    trueTimestamp: innerEnvelope.trueTimestamp,
    conversationId: innerEnvelope.conversationId,
    messageId: innerEnvelope.messageId,
  }));
  const paddedEnvelope = padToBlockSize(serialized);

  // 2. Perform Kyber KEM encapsulation
  const { cipherText, sharedSecret } = ml_kem1024.encapsulate(recipientPublicKey);

  // 3. Derive envelope key via HKDF
  const envelopeKey = await hkdfDerive(
    sharedSecret,
    new Uint8Array(32), // Empty salt
    new TextEncoder().encode('sealed-sender-v1'),
    32
  );

  // 4. Encrypt with AES-256-GCM
  const encrypted = await encryptAESGCM(envelopeKey, paddedEnvelope);

  return {
    kemCiphertext: cipherText,
    nonce: encrypted.nonce,
    encryptedContent: encrypted.ciphertext,
  };
}

/**
 * Decrypt a sealed envelope using the recipient's private key
 *
 * @param envelope The sealed envelope to decrypt
 * @param recipientPrivateKey Recipient's sealed sender Kyber private key
 * @returns The decrypted inner envelope
 */
export async function sealedSenderDecrypt(
  envelope: SealedEnvelope,
  recipientPrivateKey: Uint8Array
): Promise<InnerEnvelope> {
  if (recipientPrivateKey.length !== KYBER1024_PRIVATE_KEY_SIZE) {
    throw new Error(
      `Invalid recipient private key size: expected ${KYBER1024_PRIVATE_KEY_SIZE}, got ${recipientPrivateKey.length}`
    );
  }

  // 1. Decapsulate to get shared secret
  const sharedSecret = ml_kem1024.decapsulate(envelope.kemCiphertext, recipientPrivateKey);

  // 2. Derive envelope key (same derivation as encryption)
  const envelopeKey = await hkdfDerive(
    sharedSecret,
    new Uint8Array(32),
    new TextEncoder().encode('sealed-sender-v1'),
    32
  );

  // 3. Decrypt inner envelope
  const paddedEnvelope = await decryptAESGCM(envelopeKey, envelope.encryptedContent, envelope.nonce);

  // 4. Unpad and parse
  const serialized = unpadFromBlockSize(paddedEnvelope);
  const parsed = JSON.parse(new TextDecoder().decode(serialized));

  return {
    senderId: parsed.senderId,
    senderIdentityKey: parsed.senderIdentityKey,
    senderKeyFingerprint: parsed.senderKeyFingerprint,
    messageContent: fromBase64(parsed.messageContent),
    trueTimestamp: parsed.trueTimestamp,
    conversationId: parsed.conversationId,
    messageId: parsed.messageId,
  };
}

/**
 * Compute a delivery token for sealed sender authorization
 *
 * The token proves the sender has a valid shared secret with the recipient
 * without revealing the sender's identity to the server.
 *
 * @param sharedSecret Shared secret from X3DH or ongoing session
 * @param deliveryVerifier Recipient's delivery verifier from prekey bundle
 * @returns Delivery token (32 bytes)
 */
export async function computeDeliveryToken(
  sharedSecret: Uint8Array,
  deliveryVerifier: Uint8Array
): Promise<Uint8Array> {
  // token = HKDF(sharedSecret, deliveryVerifier, "sealed-sender-token-v1")
  const input = concat(
    deliveryVerifier,
    new TextEncoder().encode('sealed-sender-token-v1')
  );

  return await hkdfDerive(
    sharedSecret,
    input,
    new TextEncoder().encode('delivery-token'),
    32
  );
}

/**
 * Hash a delivery token (for server-side storage)
 * Server stores only the hash, never the raw token
 */
export async function hashDeliveryToken(token: Uint8Array): Promise<string> {
  const hash = await sha256(token);
  return toHex(hash);
}

/**
 * Get timestamp bucket (15-minute window)
 *
 * @param timestamp Unix timestamp in milliseconds
 * @returns Bucket timestamp (rounded to 15 minutes)
 */
export function getTimestampBucket(timestamp: number = Date.now()): number {
  return Math.floor(timestamp / TIMESTAMP_BUCKET_MS) * TIMESTAMP_BUCKET_MS;
}

/**
 * Pad data to fixed block size for traffic analysis protection
 *
 * @param data Data to pad
 * @returns Padded data with length stored in last 2 bytes
 */
export function padToBlockSize(data: Uint8Array): Uint8Array {
  const dataLen = data.length;

  // Find the smallest block size that fits data + 2 bytes for length
  let blockSize = PADDING_BLOCK_SIZES[PADDING_BLOCK_SIZES.length - 1];
  for (const size of PADDING_BLOCK_SIZES) {
    if (size >= dataLen + 2) {
      blockSize = size;
      break;
    }
  }

  // Create padded buffer
  const padded = new Uint8Array(blockSize);
  padded.set(data);

  // Fill with random bytes (except last 2 bytes for length)
  const randomPadding = randomBytes(blockSize - dataLen - 2);
  padded.set(randomPadding, dataLen);

  // Last 2 bytes: original length (big-endian)
  padded[blockSize - 2] = (dataLen >> 8) & 0xff;
  padded[blockSize - 1] = dataLen & 0xff;

  return padded;
}

/**
 * Remove padding from block-sized data
 *
 * @param padded Padded data
 * @returns Original data without padding
 */
export function unpadFromBlockSize(padded: Uint8Array): Uint8Array {
  const paddedLen = padded.length;
  if (paddedLen < 2) {
    throw new Error(`Padded data too short: ${paddedLen} bytes`);
  }

  // Read original length from last 2 bytes (big-endian)
  const origLen = (padded[paddedLen - 2] << 8) | padded[paddedLen - 1];

  if (origLen > paddedLen - 2) {
    throw new Error(
      `Invalid padding: claimed length ${origLen} exceeds available ${paddedLen - 2}`
    );
  }

  return padded.slice(0, origLen);
}

/**
 * Serialize a sealed envelope for transmission
 */
export function serializeSealedEnvelope(envelope: SealedEnvelope): string {
  return toBase64(
    concat(
      new Uint8Array([SEALED_SENDER_VERSION]),
      new Uint8Array([(envelope.kemCiphertext.length >> 8) & 0xff, envelope.kemCiphertext.length & 0xff]),
      envelope.kemCiphertext,
      new Uint8Array([envelope.nonce.length]),
      envelope.nonce,
      envelope.encryptedContent
    )
  );
}

/**
 * Deserialize a sealed envelope from transmission format
 */
export function deserializeSealedEnvelope(serialized: string): SealedEnvelope {
  const data = fromBase64(serialized);
  let offset = 0;

  // Version
  const version = data[offset++];
  if (version !== SEALED_SENDER_VERSION) {
    throw new Error(`Unsupported sealed sender version: ${version}`);
  }

  // KEM ciphertext length and data
  const kemLen = (data[offset] << 8) | data[offset + 1];
  offset += 2;
  const kemCiphertext = data.slice(offset, offset + kemLen);
  offset += kemLen;

  // Nonce length and data
  const nonceLen = data[offset++];
  const nonce = data.slice(offset, offset + nonceLen);
  offset += nonceLen;

  // Encrypted content (rest of data)
  const encryptedContent = data.slice(offset);

  return {
    kemCiphertext,
    nonce,
    encryptedContent,
  };
}

/**
 * Create a WebSocket sealed message for 1:1 DM
 */
export async function createSealedMessage(
  innerEnvelope: InnerEnvelope,
  recipientId: string,
  recipientPublicKey: Uint8Array,
  sharedSecret: Uint8Array,
  deliveryVerifier: Uint8Array
): Promise<WSSealedMessage> {
  const envelope = await sealedSenderEncrypt(innerEnvelope, recipientPublicKey);
  const deliveryToken = await computeDeliveryToken(sharedSecret, deliveryVerifier);

  return {
    type: 'sealedMessage',
    recipientId,
    sealedContent: serializeSealedEnvelope(envelope),
    deliveryToken: toBase64(deliveryToken),
    timestampBucket: getTimestampBucket(),
  };
}

/**
 * Create a WebSocket sealed group message with fanout optimization
 *
 * Uses a content key to encrypt the inner envelope once, then seals
 * the content key to each recipient separately.
 */
export async function createSealedGroupMessage(
  innerEnvelope: InnerEnvelope,
  conversationId: string,
  recipients: Array<{
    userId: string;
    publicKey: Uint8Array;
    sharedSecret: Uint8Array;
    deliveryVerifier: Uint8Array;
  }>
): Promise<WSSealedGroupMessage> {
  // 1. Generate random content key
  const contentKey = randomBytes(32);

  // 2. Serialize and pad inner envelope
  const serialized = new TextEncoder().encode(JSON.stringify({
    senderId: innerEnvelope.senderId,
    senderIdentityKey: innerEnvelope.senderIdentityKey,
    senderKeyFingerprint: innerEnvelope.senderKeyFingerprint,
    messageContent: toBase64(innerEnvelope.messageContent),
    trueTimestamp: innerEnvelope.trueTimestamp,
    conversationId: innerEnvelope.conversationId,
    messageId: innerEnvelope.messageId,
  }));
  const paddedEnvelope = padToBlockSize(serialized);

  // 3. Encrypt inner envelope with content key
  const encryptedEnvelopeResult = await encryptAESGCM(contentKey, paddedEnvelope);

  // 4. Seal content key to each recipient
  const sealedKeys: WSSealedKey[] = [];

  for (const recipient of recipients) {
    // KEM encapsulate to recipient's public key
    const { cipherText, sharedSecret } = ml_kem1024.encapsulate(recipient.publicKey);

    // Derive key from shared secret
    const keyEncKey = await hkdfDerive(
      sharedSecret,
      new Uint8Array(32),
      new TextEncoder().encode('sealed-group-key-v1'),
      32
    );

    // Encrypt content key with derived key
    const sealedContentKeyResult = await encryptAESGCM(keyEncKey, contentKey);

    // Compute delivery token
    const deliveryToken = await computeDeliveryToken(
      recipient.sharedSecret,
      recipient.deliveryVerifier
    );

    sealedKeys.push({
      recipientId: recipient.userId,
      sealedContentKey: toBase64(concat(sealedContentKeyResult.nonce, sealedContentKeyResult.ciphertext)),
      ephemeralPublicKey: '', // Not used in this optimization
      kemCiphertext: toBase64(cipherText),
      deliveryToken: toBase64(deliveryToken),
    });
  }

  return {
    type: 'sealedGroupMessage',
    conversationId,
    encryptedEnvelope: toBase64(concat(encryptedEnvelopeResult.nonce, encryptedEnvelopeResult.ciphertext)),
    sealedKeys,
    timestampBucket: getTimestampBucket(),
  };
}

/**
 * Decrypt a sealed group message
 */
export async function decryptSealedGroupMessage(
  encryptedEnvelope: string,
  sealedKey: WSSealedKey,
  recipientPrivateKey: Uint8Array
): Promise<InnerEnvelope> {
  // 1. Decapsulate to get shared secret
  const kemCiphertext = fromBase64(sealedKey.kemCiphertext);
  const sharedSecret = ml_kem1024.decapsulate(kemCiphertext, recipientPrivateKey);

  // 2. Derive key encryption key
  const keyEncKey = await hkdfDerive(
    sharedSecret,
    new Uint8Array(32),
    new TextEncoder().encode('sealed-group-key-v1'),
    32
  );

  // 3. Decrypt content key
  const sealedContentKeyData = fromBase64(sealedKey.sealedContentKey);
  const keyNonce = sealedContentKeyData.slice(0, 12);
  const encryptedContentKey = sealedContentKeyData.slice(12);
  const contentKey = await decryptAESGCM(keyEncKey, encryptedContentKey, keyNonce);

  // 4. Decrypt inner envelope
  const envelopeData = fromBase64(encryptedEnvelope);
  const contentNonce = envelopeData.slice(0, 12);
  const encryptedContent = envelopeData.slice(12);
  const paddedEnvelope = await decryptAESGCM(contentKey, encryptedContent, contentNonce);

  // 5. Unpad and parse
  const serialized = unpadFromBlockSize(paddedEnvelope);
  const parsed = JSON.parse(new TextDecoder().decode(serialized));

  return {
    senderId: parsed.senderId,
    senderIdentityKey: parsed.senderIdentityKey,
    senderKeyFingerprint: parsed.senderKeyFingerprint,
    messageContent: fromBase64(parsed.messageContent),
    trueTimestamp: parsed.trueTimestamp,
    conversationId: parsed.conversationId,
    messageId: parsed.messageId,
  };
}
